# Enterprise Automation Services Application Assessment
## Introduction
This repository was created to present my submission for the Enterprise Automation Servics Trainee DevOps Engineer technical assessment. It will include all of the code written to fulfill the objectives of the three tasks included in the assessment, as well as this README file which will provide context for the submission and explain some of the design choices made when deciding how to achieve the task objectives. I chose to use Python for this assessment as it is a language I am familiar with which is used widely for data analysis tasks such as this. Python also has a wide variety of well documented modules which can be used to streamline tasks ranging from displaying data in a table in the console to applying natural language processing to a body of text.  
## Task 1: API Consumption and Data Display
### Objective:
Write a script to interact with an API, specifically to retrieve data and display it in a user-friendly format in the console.
### Solution:
The code written for this task can be found in the file EASTask1 which is included in the repository. The solution is presented in the form of a single function _DisplayUserData()_. The function makes use of two modules imported at the beginning of the script _requests_ and _tabulate_.

The _requests_ module provides functionality for requesting data from an API and in this case is used to import user data from the JSONPlaceholder API using the _.get()_ method in line 11. The JSONPlaceholder API data is organised into 6 common resources which can each be accessed by modifying the URL given in the _requests.get()_, here we are interested in retrieving user data from the API so we add the /users extension to the URL to retrieve only the user data with our request. We store this retrieved data in an object called _response_. When we make a call to the API using _requests.get()_, along with the user data, we retrieve some metadata which we are not interested in for the purposes of this assessment so in line 12 we filter the _response_ data by applying the _.json()_ method to our response object which returns the JSON-encoded content of the response, stored here in _UserData_ as a list of dictionaries. A python dictionary is a data structure designed to allow efficient storage and retrieval of data. Each entry in a dictionary is formed of a key:value pair, values are mapped to keys such that every value in a dictionary has an associated unique key. Keys in python dictionaries immutable, meaning once created they cannot be changed, allowing them to be treated in a way that is more efficient in terms of storage space and access times. This makes dictionaries useful for handling large data sets.]

In line 17 we begin a loop to iterate over each dictionary in the _UserData_ List. Each _User_ dictionary containes two nested dictionaries for the user's address information and information about the user's company. The choice was made to remove these nested dictionaries from the data set, replacing them with entries giving the name of the user's city of residence and their company name. This allows the data to be presented in a table which is, in my opinion, more user-friendly. Since dictionary keys are immutable, the _address_ and _company_ key names cannot be changed. Two new dictionary entries were added to the original dictionary with the city and company names respectively and the _address_ and _company_ entries were removed entirely using the _.pop()_ method. This is all done in lines 18 to 22. Dictionary entries in python cannot be reordered, meaning if we wanted to have, for example, the city name appear in our table where the address would have if it were not removed we would have needed to create an entirely new dictionary. This seemed like a waste of resources for a relatively minor asthetic change which would have little effect on the final output for the task.

Finally we display our data in the console in the form of a _tabulate_ table. The _tabulate_ module allows for easy display of plain text tables using only a single function call, handling column alignment automatically. In line 25 we call the _print()_ function to display text in the console. Within this function we call the _.tbulate()_ function from the _tabulate module_, providing the UserData list of dictionaries as our 2-dimensional data structure to be displayed and specifying that the keys of the dictionaries should be used as the table headers by setting the keyword argument _headers = 'keys'_. The asthetic choice to use the _'fancy_grid'_ format for our table was made as a personal preference, specified using the keyword _tablefmt_. The table produced as a result of calling the _DisplayUserData()_ is shown in the GIF below.
